0:10
hi I'm Edgar and I'm a software engineer
0:11
at Google hi I'm Becky and I'm a
0:13
software engineer at
0:15
Google so Edgar the question I'm going
0:18
to give you today is uh I'm going to
0:21
give you a collection of
0:23
numbers and I need you to take this
0:26
collection of numbers and find a
0:28
matching pair
0:30
that is equal to a sum that I give you
0:32
as well okay so for example the
0:36
collection of numbers could be 1
0:40
2
0:42
3 and
0:45
N9 and the sum that I'm looking
0:50
for is eight okay and then another
0:54
example just for another set of numbers
0:56
could
0:57
be a one a two a four and a
1:04
four and then again the sum that I'm
1:06
looking for is eight so in this case
1:11
there I guess what I'm trying to figure
1:13
out is
1:15
um you're looking for a pair of numbers
1:19
that that add up to eight yeah right so
1:21
in this case there isn't a pair of
1:23
numbers that add up to eight that is
1:24
true it's example and in this case it is
1:27
because the four and four add up to
1:29
eight correct okay so this is this would
1:31
be like
1:32
uh no and this is like yes okay yes you
1:37
ultimately have to tell if the if the
1:39
par okay um so how are these numbers
1:42
given can I assume that they're like in
1:44
memory um an array or something yeah
1:48
they're in memory you can go with an
1:49
array you can also assume that they're
1:51
in that they're ordered in asending
1:52
order okay oh interesting okay
1:56
um so how about repeating elements can I
1:59
assume there will be like for instance
2:02
here uh what if I I guess what what if I
2:05
didn't have that four could I use like
2:07
the four and the four to get that eight
2:09
you can't repeat the same element at the
2:11
same index twice but certainly the same
2:13
number may appear twice like okay so
2:17
like that would be would be a yes uh how
2:19
about these numbers are they integers or
2:21
are they floating point or you can
2:24
assume they'll always be integers okay
2:26
uh negatives positives uh negatives
2:29
could happen
2:30
Okay cool
2:33
so well the first the simplest solution
2:35
of course is just comparing every single
2:38
possible pair uh so I could just have
2:40
two four Loops one scanning the whole
2:42
thing and then the second one starting
2:44
from let's say you have the I Loop and
2:46
then the J Loop starting from I + one so
2:48
that I don't repeat the same value and
2:51
just testing all of them if the sum is
2:52
equal to the to the Target
2:55
sum uh I mean that's obviously not very
2:59
efficient that that's that would be like
3:01
a way to solve it that would work uh it
3:03
certainly would be time consuming I
3:05
think as far as obstacles is concerned
3:07
so is there any kind of example that
3:09
could be a little bit F yeah I think
3:11
that that would be quadratic so better
3:13
than quadratic uh well since it's sorted
3:18
so okay I guess I need to figure
3:20
out when I have a number what I'm
3:23
looking for is if there's another number
3:26
that sounds to eight so so if I have a
3:28
one what I need to figure out is if
3:30
there's a seven somewhere in the in the
3:33
um array and if that's the case if it's
3:36
sorted then I can just do binary search
3:39
uh I guess if I go here and I binary
3:41
search for a seven M um then I go here
3:45
and I binary search for a six which is
3:47
the complement of that and when I go
3:50
here I binary search for a five and in
3:53
the end I just don't do anything and so
3:55
in this case I would solve it like that
3:57
uh so that's a bit better than quadratic
4:00
I guess binary resarch is is a log uh
4:03
algorithm in a sorted list um also a
4:07
good answer okay still kind of
4:12
slow okay so what if you took a look
4:17
at instead of going a binary search
4:20
which is
4:20
unidirectional what if you started with
4:23
a pair of numbers to begin with okay and
4:26
then worked your way sort of inward from
4:28
there
4:30
uh let's see so if I okay let me try to
4:34
bound this thing so the the largest
4:38
possible sum I guess uh would be the
4:41
last two
4:42
values that would be the largest
4:44
possible sum and the smallest possible
4:47
sum would be the the two smallest right
4:49
so so anything in between um ah okay so
4:54
the range of the possible values is that
4:57
right so there's nothing that is
4:59
probably small there's nothing that can
5:00
be smaller than this value right there's
5:02
nothing that can be larger than that
5:04
value and you have somewhere
5:07
move that's okay so if this sum is 10 in
5:13
this case it's too large mhm so I need
5:16
to find a smaller sum so I could just
5:18
move this one over
5:21
here and if that is too small now and I
5:26
need to move that one over there okay so
5:27
I can I think I can just do it with with
5:29
that in a in a linear solution just
5:35
moving at each teration I either move
5:38
the high one lower if I am if my pair is
5:43
too large and I move my lower higher if
5:47
my pair is too small and I end whenever
5:51
I either find two like uh in this case I
5:54
I either find a pair that adds up to
5:56
eight or whenever they cross so but
5:59
every at every point I'm moving one of
6:01
them so they would have to at least
6:03
cross and I move exactly one so that
6:06
means that it's linear yeah so that that
6:08
would be a a way of solving that problem
6:10
and how does that how does it make that
6:12
faster than a binary search okay so in
6:14
the binary search case I was doing log
6:17
for finding but I had to repeat that for
6:19
every element so that was an N log n
6:21
solution in this case I just need to do
6:25
that moving
6:27
scanning the one time so it's linear
6:30
solution so that's that's faster right
6:32
right okay so before maybe we could get
6:34
to coding it but before we do that maybe
6:36
you could explain so you you explained
6:38
it in a non-w working example maybe you
6:40
could follow through that same process
6:42
in a working okay yeah so here I would
6:44
start with this and that right so it's
6:47
five it's smaller than eight so I move
6:49
this one here so that's six that's
6:51
smaller than eight so I go here and then
6:53
that's eight so that's true and I return
6:56
excellent yeah I think that would work
6:58
okay so what coding language would you
7:00
prefer to to do this in um I I prefer
7:03
C++ if that's okay C++ works okay all
7:06
right go for it ah perfect let's see so
7:10
okay uh now I realize that I haven't
7:13
figured out what I need to return so do
7:16
I want the pair the indices of the pair
7:19
or whether I just found it or not so uh
7:23
for the purposes of the example we'll go
7:25
with whether you found it or not but
7:27
let's say you were going to return the
7:29
pair how could that become a problem if
7:31
there was no pair so I mean building the
7:33
pair would be easy right so I I would
7:35
just return the
7:37
pair if I didn't find it then I would
7:39
need to return some sort of like Boolean
7:42
so I guess I could make a data structure
7:44
that has a Boolean that the notes
7:46
whether the pair is valid or not like
7:48
has has it been found so like a like a
7:50
bull
7:52
found and then a
7:54
pair uh values or something like that
7:58
those together and then this is the
8:00
thing that you return I mean it's not
8:02
very elegant but it's workable mhh um
8:07
rather than going with a custom object
8:09
maybe we'll just return a Boolean then
8:11
okay that that makes it a lot easier yes
8:14
but it's good to know that you thought
8:15
about what might you might have to do if
8:17
there is no viable results
8:20
mhm okay so let's just call it has pair
8:24
with some I guess that's uh
8:29
and
8:31
so I I'm okay just receiving whatever I
8:34
would like to receive it as a vector say
8:37
Vector is fine yeah
8:38
sure and we said inss are fine inss are
8:43
fine uh this is my
8:46
data and then I have an INT which is my
8:52
sum okay so like I said I want sort of
8:56
an INT uh my low which is
9:00
zero then my
9:03
high which is uh the
9:07
data
9:08
size
9:11
minus1 and then what I'm going to do is
9:14
while these are well while while my low
9:17
is strictly lower than my high
9:22
okay as soon as they are touching then I
9:26
know that I can't guarantee that they're
9:28
different so that that's where I should
9:30
stop okay my well my low is less than my
9:34
high and this also solves the problem of
9:37
what happens if this is empty because
9:39
then if this is empty this would be a
9:41
minus one and then that would be
9:44
violated so I would never enter and
9:46
access any of the value so that that's
9:48
fine so while low is less than high I
9:52
guess if my
9:55
data at
9:57
low plus my
10:00
data at
10:02
high is the same as my target uh my
10:05
target which is called sum
10:08
mhm then I have found it that's it
10:11
that's my pair and here is where I would
10:12
construct that pair if I needed to
10:14
return it but like you say for now I can
10:16
just return
10:20
true
10:23
now if this is larger than some and this
10:26
is lower than some so I think I'm better
10:29
than just doing it three times I'm just
10:31
going to store it in a in a
10:33
variable uh which is my
10:38
S is that and then say
10:43
if s is my
10:47
sum then return
10:51
true okay I'm going to stop you right
10:53
there okay excellent solution I see what
10:55
you're getting at here but now I'm going
10:57
to throw a little wrench into the mix
10:59
for oh
11:01
boy I can no longer guarantee for you
11:04
that the numbers in this collection are
11:06
sorted okay so you have to think of a
11:09
different way to compare them against
11:12
each other now I mean if if the first
11:14
thing I do is just sort of course then I
11:17
I solve this problem the same way right
11:19
so that would be still an end Logan
11:21
solution it would which would be like
11:23
the same as as the the binary search as
11:26
well but it's too simp for Google okay
11:28
so you want faster than that
11:32
okay okay let's see so if I go back to
11:36
this idea okay so let me erase
11:40
this if I go back to this idea of when I
11:43
look at a number what I need to figure
11:45
out is if the complement is in the
11:49
rest the compliment meaning the the yeah
11:52
the eight minus this value right so in
11:54
this case when I have the one I need to
11:56
figure out if seven is in the rest okay
11:59
if I cannot sort and searching that will
12:01
be linear so that's not a very good idea
12:04
but maybe I can do it the other way
12:05
around so I build it up little by little
12:09
and instead of just sort of asking a
12:10
blanket is there anywhere I just ask
12:13
have I seen it in the past so for
12:15
instance if I'm here what I need to find
12:18
out is if I have seen 8 minus 3 have I
12:21
seen five in the past that would work um
12:25
so you'd have to store five or I guess
12:28
it's the same but I could be storing the
12:31
complement and I just ask have I seen
12:34
three as a complement of anything of the
12:36
things before so like I I insert a seven
12:38
when I see a one sure I insert a six if
12:40
I see a two you insert the compliment
12:42
and then yes I insert the compliment and
12:44
then when I get here I ask is the is
12:47
this the complement of anything I have
12:49
seen in the past right so I can do I can
12:52
use a data structure that is very good
12:54
for for lookups okay right so I can do
12:57
something like a hash table which has
12:58
like a constant time
13:00
lookup um hash table though hash table
13:05
do you need a key in this case I I guess
13:07
I don't need a I mean I just need the
13:09
values the the the the elements I don't
13:11
I don't actually want to store any
13:14
payload so yeah I guess a hash set would
13:17
be the the thing to do so I hash set all
13:20
of the complement and then I look for
13:22
them I I need to be careful though uh
13:25
how am I going to deal with the case of
13:28
uh repeated
13:30
elements uh so I don't want to be able
13:34
to say oh I have a four yes of course I
13:36
have a four I'm done right I if I have
13:39
this I have a four I'd have it so I'm
13:41
done that would be a wrong
13:44
solution I guess I need to be careful
13:46
there
13:48
so okay okay okay so here's an idea I
13:52
only look for things so what I'm here I
13:54
only look for things that I have seen
13:55
before so as long as I check before I
13:58
insert things MH that should
14:02
work and then when I add it
14:06
here this one will find that because
14:08
it's in the previous one so I I think
14:10
that works yeah sounds good um let's Cod
14:13
it okay very well so let's see
14:17
uh so like I was saying bll of
14:22
has a
14:24
pair with
14:27
some with my okay can I just like uh my
14:31
v i mean a const vector of
14:35
and uh
14:37
data and then my
14:40
int sum
14:43
okay so I need a hash set so in C++
14:47
that's an unordered
14:52
set of integers still and I'm going to
14:56
call it complement uh well I don't want
14:58
to write compliments all the time so I'm
15:00
just going to call it comp and say these
15:03
are the
15:06
compliments as see whatever I need to
15:09
get the target sum yeah and so as I said
15:14
I just need to be building it up little
15:15
by little so I do have four uh my
15:19
in uh
15:21
value for each of the values in the data
15:25
mhm I am going to first check and then
15:29
insert so
15:31
if my complement so I check if I have
15:35
seen
15:37
it first yeah and if I have seen it so
15:42
that means if it's not in the end
15:46
mhm then that's it um that should be a
15:49
return
15:50
true because this current element and
15:53
something that I have seen in the past
15:55
add up to the sum mhm so obviously it
15:59
depends on what I've been inserting so
16:01
that's what I'm going to do here my
16:04
compliments is going to
16:06
be inserting I I don't remember I think
16:10
it's add for an unordered set but
16:12
there's probably there's something um
16:15
it's either add or insert or something
16:18
yeah uh so I add not the value but the
16:23
complement like I said so I do the
16:26
sum minus value
16:30
I feel like I probably need to uh go
16:34
through an example but anyway to make
16:36
sure that this is correct
16:39
uh but I think that's it um Let me let
16:43
me go through through some examples to
16:46
to make sure I'm going yes so okay so I
16:51
have a I have a set my my compliments is
16:53
a set which starts empty I'm going to
16:56
run through both they're kind of the
16:58
same at the begin so that should be fine
17:00
uh so I have nothing in I check for my
17:03
first value which is a one m i don't
17:06
find anything obviously MH and then uh I
17:09
add 8 minus one so I add a seven here
17:12
okay so now I have a
17:15
seven um then I go for the next one two
17:18
I look for whether there's a two there
17:21
no there isn't but if I had had a six
17:24
here adding the complement would have
17:27
find the two so that would that would be
17:28
good so that that makes sense okay the
17:30
seven it's not there so I just add now
17:33
the six
17:34
mhm and here's where they start to
17:37
diverge uh the next case is I get a
17:41
three have I seen a three no well have I
17:45
seen the complement of a three no so I
17:48
just shove in the three uh nice three is
17:52
compliment good point yeah and then the
17:54
last one no I have not there's no nine
17:56
here so it would correctly turn false
17:59
right now what about the other
18:01
one the other case I get a
18:04
four I have not seen a uh the complement
18:07
of four so I put the four in okay
18:10
because it's 8 - 4 is four M and
18:14
then when I get to this one I have found
18:18
it so I correctly return true value is
18:22
equal to compliment yeah so the value
18:25
would be four I look here in my
18:27
compliments and I do find it so return
18:29
true okay so that works uh what happens
18:31
with an empty uh the empty one should
18:34
never return true because you don't have
18:35
a pair so that's fine if you have only
18:37
one thing you never would compare again
18:40
so that's fine so it seems like that
18:42
that works uh there is one
18:45
issue this could underflow so um about
18:50
that okay let's not worry about that so
18:51
I think this is this is a uh the right
18:54
solution um so it's linear because I am
18:58
doing being constant amount of work the
19:00
lookup is constant adding is constant
19:03
for an ordered set and I do it for all
19:05
of the values in the input so that's
19:08
linear and the memory is I guess linear
19:11
as well because the worst case scenario
19:13
I have added all of them to the set
19:16
would you do anything differently here
19:17
if there were 10 million integers in
19:20
this
19:22
collection okay so let's see um so if
19:26
the input is large does it still fit in
19:29
memory
19:30
or probably not at this point okay so if
19:33
it doesn't fit in memory what I can do
19:37
okay so is the range of these
19:40
values Limited in some way um you can
19:43
assume they might be yeah okay okay okay
19:46
so if this if my set fits in memory
19:50
mhm but my whole input doesn't fit in
19:54
memory then I can just sort of process
19:57
it in chunks right uh I chunk it and I
20:00
just put it in a set and I accumulate it
20:02
in a set M uh if we can do it in
20:04
parallel then it's kind of the same
20:06
thing right so now you have multiple
20:08
computers each one prod processing each
20:11
bit of it of the input each one
20:13
producing a
20:16
um set of compliments that this bit has
20:19
seen and we just sort of merge them um I
20:23
think we have enough computers
20:25
really yeah so the merging would be a
20:27
bit tricky because we want to make
20:30
sure that again we don't we don't sort
20:33
of look for the thing that we have put
20:35
in
20:36
so uh I guess as long as each individual
20:42
computer is testing this in the right
20:44
order when we merge them now we can say
20:47
oh well those two are are are correctly
20:50
um so if I have a four in one computer
20:52
and a four in the other computer when I
20:53
merge them I would need to be careful
20:55
that that I reconcile them but other
20:57
than that I think that would be the only
20:59
consideration yeah okay yeah excellent
21:02
great great
21:05
[Music]
21:07
job all right so just to recap that
21:10
interview I just want to go over a
21:11
couple of things that you that you
21:14
should be aware of when you're when
21:15
you're interviewing and some of the
21:16
things that Edgar did very well so the
21:18
first thing that he did was he asked for
21:20
clarification to the problem so if you
21:22
don't understand fully understand the
21:24
question please feel free to ask for
21:26
clarification or ask to have it repeated
21:28
you can write it down you can write it
21:30
down verbatim if needs to be whatever
21:32
you need to do to get a complete
21:34
understanding of the question that's
21:35
being asked and I think some of his
21:37
clarification questions were could they
21:39
be negative numbers or floating Point
21:41
numbers and and the answer to that
21:43
really does affect through outcome of
21:44
his code so it was really great that he
21:46
asked that question another thing that
21:48
he did is he while he was going through
21:50
his solution even before he started
21:52
writing code down he thought out loud
21:55
constantly uh constantly thinking out
21:58
loud is probably the best thing you can
21:59
do in the interview because it gives the
22:01
interviewee the opportunity
22:03
to uh see your thought process and and
22:07
use that to possibly course correct you
22:10
more towards the the question that they
22:12
were asking or to to uh feed off of that
22:15
and ask you more questions that might
22:17
help you demonstrate your knowledge even
22:19
further because you may have said
22:20
something that they can expand upon uh
22:22
but in the very least it's going to help
22:24
you to work that problem out and there's
22:26
and there's nothing wrong with working
22:27
that problem out with somebody else two
22:29
minds are better than one right so
22:31
please please think out loud uh another
22:33
thing that he did really great is he um
22:38
thought through everything before he
22:39
started writing something down so we we
22:41
thought about how we were going to do it
22:43
we actually went through two iterations
22:44
right the first thing the thing at the
22:45
top of his mind isn't wasn't the best
22:48
solution and it it's not going to be the
22:49
best solution for anybody so think
22:52
through what you want to do uh and then
22:54
you might get challenged by the
22:56
interviewer to think better faster uh
22:59
quicker more efficiently think through
23:01
that solution and then ultimately when
23:03
you you feel you both feel like you're
23:04
at a spot where you can code it then you
23:06
can start coding it down on the screen
23:07
or on paper so uh that's another great
23:10
thing to do uh another thing that he did
23:13
really well that I would encourage
23:14
everyone to do is to test it test it in
23:16
real time so I gave him two example sets
23:19
here he he had something that he could
23:21
test with if your interviewer doesn't
23:23
give you an example please make one up
23:25
you test test your solution does it work
23:27
does it vet and then think about edge
23:29
cases edge cases can be important so in
23:31
his case he thought about if he had an
23:33
empty collection and he tested his his
23:35
logic with an empty collection it was
23:37
really nice to see him thinking about
23:39
those edge cases and and bringing them
23:41
up in the interview so uh yeah
23:44
clarifications think out loud talk
23:48
through talk before you write and then
23:50
test your solution